{"ast":null,"code":"import axios from 'axios';\n// 使用 localhost 而不是 IP 地址\nconst API_URL = 'http://localhost:8000';\nconst WS_URL = 'ws://localhost:8000';\n\n// 配置 axios\nconst axiosInstance = axios.create({\n  baseURL: API_URL,\n  timeout: 10000,\n  // 10 秒超时\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\n\n// 添加重试逻辑\nconst retryRequest = async (fn, retries = 3, delay = 1000) => {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return retryRequest(fn, retries - 1, delay * 2);\n    }\n    throw error;\n  }\n};\nexport const gameService = {\n  createGame: async (playerCount, maxBatches, tasksPerBatch) => {\n    console.log('Creating game with params:', {\n      playerCount,\n      maxBatches,\n      tasksPerBatch\n    });\n    return retryRequest(async () => {\n      const response = await axiosInstance.post('/games/create', null, {\n        params: {\n          player_count: playerCount,\n          max_batches: maxBatches,\n          tasks_per_batch: tasksPerBatch\n        }\n      });\n      console.log('Game created:', response.data);\n      return response.data.game_id;\n    });\n  },\n  checkGameExists: async gameId => {\n    console.log('Checking if game exists:', gameId);\n    return retryRequest(async () => {\n      const response = await axiosInstance.get(`/games/${gameId}/exists`);\n      console.log('Game exists response:', response.data);\n      return response.data.exists;\n    });\n  },\n  joinGame: async (gameId, playerName) => {\n    console.log('Joining game:', {\n      gameId,\n      playerName\n    });\n    return retryRequest(async () => {\n      const response = await axiosInstance.post(`/games/${gameId}/join`, null, {\n        params: {\n          player_name: playerName\n        }\n      });\n      console.log('Join game response:', response.data);\n      return response.data.player_id;\n    });\n  },\n  startGame: async gameId => {\n    console.log('Starting game:', gameId);\n    return retryRequest(async () => {\n      await axiosInstance.post(`/games/${gameId}/start`);\n      console.log('Game started');\n    });\n  },\n  getGameState: async gameId => {\n    console.log('Getting game state:', gameId);\n    return retryRequest(async () => {\n      const response = await axiosInstance.get(`/games/${gameId}`);\n      console.log('Game state:', response.data);\n      return response.data;\n    });\n  }\n};\nexport class WebSocketService {\n  constructor(gameId, playerId, onGameUpdate) {\n    this.ws = null;\n    this.gameId = void 0;\n    this.playerId = void 0;\n    this.onGameUpdate = void 0;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.isConnecting = false;\n    this.handleMessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        console.log('WebSocket message received:', message);\n        if (message.type === 'game_update' || message.type === 'game_started') {\n          console.log('Updating game state:', message.data);\n          this.onGameUpdate(message.data);\n        }\n      } catch (error) {\n        console.error('Error handling message:', error);\n      }\n    };\n    this.handleOpen = () => {\n      console.log('WebSocket connection opened');\n      this.isConnecting = false;\n      this.reconnectAttempts = 0;\n      this.getGameState();\n    };\n    this.handleClose = () => {\n      console.log('WebSocket connection closed');\n      this.isConnecting = false;\n      this.handleReconnect();\n    };\n    this.handleError = error => {\n      console.error('WebSocket error:', error);\n      this.isConnecting = false;\n    };\n    this.gameId = gameId;\n    this.playerId = playerId;\n    this.onGameUpdate = onGameUpdate;\n    console.log('WebSocket service initialized:', {\n      gameId,\n      playerId\n    });\n  }\n  connect() {\n    if (this.isConnecting) {\n      console.log('Connection attempt already in progress');\n      return;\n    }\n    this.isConnecting = true;\n    console.log('Connecting WebSocket...');\n    try {\n      this.ws = new WebSocket(`${WS_URL}/ws/${this.playerId}`);\n      this.ws.onmessage = this.handleMessage.bind(this);\n      this.ws.onopen = this.handleOpen.bind(this);\n      this.ws.onclose = this.handleClose.bind(this);\n      this.ws.onerror = this.handleError.bind(this);\n    } catch (error) {\n      console.error('Error creating WebSocket:', error);\n      this.handleReconnect();\n    }\n  }\n  async getGameState() {\n    try {\n      const gameState = await gameService.getGameState(this.gameId);\n      this.onGameUpdate(gameState);\n    } catch (error) {\n      console.error('Error getting game state:', error);\n    }\n  }\n  handleReconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`);\n      this.reconnectTimeout = setTimeout(() => {\n        this.connect();\n      }, delay);\n    }\n  }\n  completeTask(taskId) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      const message = {\n        type: 'complete_task',\n        game_id: this.gameId,\n        task_id: taskId\n      };\n      console.log('Sending complete task message:', message);\n      this.ws.send(JSON.stringify(message));\n    } else {\n      console.error('WebSocket not connected');\n      this.connect();\n    }\n  }\n  disconnect() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n    }\n    if (this.ws) {\n      console.log('Disconnecting WebSocket');\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}","map":{"version":3,"names":["axios","API_URL","WS_URL","axiosInstance","create","baseURL","timeout","headers","retryRequest","fn","retries","delay","error","Promise","resolve","setTimeout","gameService","createGame","playerCount","maxBatches","tasksPerBatch","console","log","response","post","params","player_count","max_batches","tasks_per_batch","data","game_id","checkGameExists","gameId","get","exists","joinGame","playerName","player_name","player_id","startGame","getGameState","WebSocketService","constructor","playerId","onGameUpdate","ws","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","isConnecting","handleMessage","event","message","JSON","parse","type","handleOpen","handleClose","handleReconnect","handleError","connect","WebSocket","onmessage","bind","onopen","onclose","onerror","gameState","clearTimeout","Math","min","pow","completeTask","taskId","readyState","OPEN","task_id","send","stringify","disconnect","close"],"sources":["/Users/huanghao/Desktop/online multiplayer coin game/frontend/src/services/gameService.ts"],"sourcesContent":["import axios from 'axios';\nimport { Game, WebSocketMessage } from '../types';\n\n// 使用 localhost 而不是 IP 地址\nconst API_URL = 'http://localhost:8000';\nconst WS_URL = 'ws://localhost:8000';\n\n// 配置 axios\nconst axiosInstance = axios.create({\n    baseURL: API_URL,\n    timeout: 10000,  // 10 秒超时\n    headers: {\n        'Content-Type': 'application/json'\n    }\n});\n\n// 添加重试逻辑\nconst retryRequest = async (fn: () => Promise<any>, retries = 3, delay = 1000) => {\n    try {\n        return await fn();\n    } catch (error) {\n        if (retries > 0) {\n            await new Promise(resolve => setTimeout(resolve, delay));\n            return retryRequest(fn, retries - 1, delay * 2);\n        }\n        throw error;\n    }\n};\n\nexport const gameService = {\n    createGame: async (playerCount: number, maxBatches: number, tasksPerBatch: number): Promise<string> => {\n        console.log('Creating game with params:', { playerCount, maxBatches, tasksPerBatch });\n        return retryRequest(async () => {\n            const response = await axiosInstance.post('/games/create', null, {\n                params: { player_count: playerCount, max_batches: maxBatches, tasks_per_batch: tasksPerBatch }\n            });\n            console.log('Game created:', response.data);\n            return response.data.game_id;\n        });\n    },\n\n    checkGameExists: async (gameId: string): Promise<boolean> => {\n        console.log('Checking if game exists:', gameId);\n        return retryRequest(async () => {\n            const response = await axiosInstance.get(`/games/${gameId}/exists`);\n            console.log('Game exists response:', response.data);\n            return response.data.exists;\n        });\n    },\n\n    joinGame: async (gameId: string, playerName: string): Promise<string> => {\n        console.log('Joining game:', { gameId, playerName });\n        return retryRequest(async () => {\n            const response = await axiosInstance.post(`/games/${gameId}/join`, null, {\n                params: { player_name: playerName }\n            });\n            console.log('Join game response:', response.data);\n            return response.data.player_id;\n        });\n    },\n\n    startGame: async (gameId: string): Promise<void> => {\n        console.log('Starting game:', gameId);\n        return retryRequest(async () => {\n            await axiosInstance.post(`/games/${gameId}/start`);\n            console.log('Game started');\n        });\n    },\n\n    getGameState: async (gameId: string): Promise<Game> => {\n        console.log('Getting game state:', gameId);\n        return retryRequest(async () => {\n            const response = await axiosInstance.get(`/games/${gameId}`);\n            console.log('Game state:', response.data);\n            return response.data;\n        });\n    }\n};\n\nexport class WebSocketService {\n    private ws: WebSocket | null = null;\n    private gameId: string;\n    private playerId: string;\n    private onGameUpdate: (game: Game) => void;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = 5;\n    private reconnectTimeout: NodeJS.Timeout | null = null;\n    private isConnecting: boolean = false;\n\n    constructor(gameId: string, playerId: string, onGameUpdate: (game: Game) => void) {\n        this.gameId = gameId;\n        this.playerId = playerId;\n        this.onGameUpdate = onGameUpdate;\n        console.log('WebSocket service initialized:', { gameId, playerId });\n    }\n\n    connect() {\n        if (this.isConnecting) {\n            console.log('Connection attempt already in progress');\n            return;\n        }\n\n        this.isConnecting = true;\n        console.log('Connecting WebSocket...');\n        \n        try {\n            this.ws = new WebSocket(`${WS_URL}/ws/${this.playerId}`);\n            \n            this.ws.onmessage = this.handleMessage.bind(this);\n            this.ws.onopen = this.handleOpen.bind(this);\n            this.ws.onclose = this.handleClose.bind(this);\n            this.ws.onerror = this.handleError.bind(this);\n        } catch (error) {\n            console.error('Error creating WebSocket:', error);\n            this.handleReconnect();\n        }\n    }\n\n    private handleMessage = (event: MessageEvent) => {\n        try {\n            const message = JSON.parse(event.data);\n            console.log('WebSocket message received:', message);\n            \n            if (message.type === 'game_update' || message.type === 'game_started') {\n                console.log('Updating game state:', message.data);\n                this.onGameUpdate(message.data);\n            }\n        } catch (error) {\n            console.error('Error handling message:', error);\n        }\n    };\n\n    private handleOpen = () => {\n        console.log('WebSocket connection opened');\n        this.isConnecting = false;\n        this.reconnectAttempts = 0;\n        this.getGameState();\n    };\n\n    private handleClose = () => {\n        console.log('WebSocket connection closed');\n        this.isConnecting = false;\n        this.handleReconnect();\n    };\n\n    private handleError = (error: Event) => {\n        console.error('WebSocket error:', error);\n        this.isConnecting = false;\n    };\n\n    private async getGameState() {\n        try {\n            const gameState = await gameService.getGameState(this.gameId);\n            this.onGameUpdate(gameState);\n        } catch (error) {\n            console.error('Error getting game state:', error);\n        }\n    }\n\n    private handleReconnect() {\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n        }\n\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.reconnectAttempts++;\n            const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts - 1), 10000);\n            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`);\n            \n            this.reconnectTimeout = setTimeout(() => {\n                this.connect();\n            }, delay);\n        }\n    }\n\n    completeTask(taskId: string) {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            const message = {\n                type: 'complete_task',\n                game_id: this.gameId,\n                task_id: taskId\n            };\n            console.log('Sending complete task message:', message);\n            this.ws.send(JSON.stringify(message));\n        } else {\n            console.error('WebSocket not connected');\n            this.connect();\n        }\n    }\n\n    disconnect() {\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n        }\n        \n        if (this.ws) {\n            console.log('Disconnecting WebSocket');\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}