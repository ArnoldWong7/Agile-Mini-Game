{"ast":null,"code":"import axios from 'axios';\nconst API_URL = 'http://localhost:8000';\nexport const gameService = {\n  createGame: async (playerCount, maxBatches, tasksPerBatch) => {\n    const response = await axios.post(`${API_URL}/games/create`, null, {\n      params: {\n        player_count: playerCount,\n        max_batches: maxBatches,\n        tasks_per_batch: tasksPerBatch\n      }\n    });\n    return response.data.game_id;\n  },\n  checkGameExists: async gameId => {\n    const response = await axios.get(`${API_URL}/games/${gameId}/exists`);\n    return response.data.exists;\n  },\n  joinGame: async (gameId, playerName) => {\n    const response = await axios.post(`${API_URL}/games/${gameId}/join`, null, {\n      params: {\n        player_name: playerName\n      }\n    });\n    return response.data.player_id;\n  },\n  startGame: async gameId => {\n    await axios.post(`${API_URL}/games/${gameId}/start`);\n  },\n  getGameState: async gameId => {\n    const response = await axios.get(`${API_URL}/games/${gameId}`);\n    return response.data;\n  }\n};\nexport class WebSocketService {\n  constructor(gameId, playerId, onGameUpdate) {\n    this.ws = null;\n    this.gameId = void 0;\n    this.playerId = void 0;\n    this.onGameUpdate = void 0;\n    this.gameId = gameId;\n    this.playerId = playerId;\n    this.onGameUpdate = onGameUpdate;\n  }\n  connect() {\n    this.ws = new WebSocket(`ws://localhost:8000/ws/${this.playerId}`);\n    this.ws.onmessage = event => {\n      const message = JSON.parse(event.data);\n      if (message.type === 'game_update' || message.type === 'game_started') {\n        this.onGameUpdate(message.data);\n      }\n    };\n    this.ws.onclose = () => {\n      console.log('WebSocket connection closed');\n      // 可以在这里添加重连逻辑\n    };\n  }\n  completeTask(taskId) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({\n        type: 'complete_task',\n        game_id: this.gameId,\n        task_id: taskId\n      }));\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n}","map":{"version":3,"names":["axios","API_URL","gameService","createGame","playerCount","maxBatches","tasksPerBatch","response","post","params","player_count","max_batches","tasks_per_batch","data","game_id","checkGameExists","gameId","get","exists","joinGame","playerName","player_name","player_id","startGame","getGameState","WebSocketService","constructor","playerId","onGameUpdate","ws","connect","WebSocket","onmessage","event","message","JSON","parse","type","onclose","console","log","completeTask","taskId","readyState","OPEN","send","stringify","task_id","disconnect","close"],"sources":["/Users/huanghao/Desktop/online multiplayer task game/frontend/src/services/gameService.ts"],"sourcesContent":["import axios from 'axios';\nimport { Game, Player } from '../types';\n\nconst API_URL = 'http://localhost:8000';\n\nexport const gameService = {\n    createGame: async (playerCount: number, maxBatches: number, tasksPerBatch: number): Promise<string> => {\n        const response = await axios.post(`${API_URL}/games/create`, null, {\n            params: { player_count: playerCount, max_batches: maxBatches, tasks_per_batch: tasksPerBatch }\n        });\n        return response.data.game_id;\n    },\n\n    checkGameExists: async (gameId: string): Promise<boolean> => {\n        const response = await axios.get(`${API_URL}/games/${gameId}/exists`);\n        return response.data.exists;\n    },\n\n    joinGame: async (gameId: string, playerName: string): Promise<string> => {\n        const response = await axios.post(`${API_URL}/games/${gameId}/join`, null, {\n            params: { player_name: playerName }\n        });\n        return response.data.player_id;\n    },\n\n    startGame: async (gameId: string): Promise<void> => {\n        await axios.post(`${API_URL}/games/${gameId}/start`);\n    },\n\n    getGameState: async (gameId: string): Promise<Game> => {\n        const response = await axios.get(`${API_URL}/games/${gameId}`);\n        return response.data;\n    }\n};\n\nexport class WebSocketService {\n    private ws: WebSocket | null = null;\n    private gameId: string;\n    private playerId: string;\n    private onGameUpdate: (game: Game) => void;\n\n    constructor(gameId: string, playerId: string, onGameUpdate: (game: Game) => void) {\n        this.gameId = gameId;\n        this.playerId = playerId;\n        this.onGameUpdate = onGameUpdate;\n    }\n\n    connect() {\n        this.ws = new WebSocket(`ws://localhost:8000/ws/${this.playerId}`);\n        \n        this.ws.onmessage = (event) => {\n            const message = JSON.parse(event.data);\n            if (message.type === 'game_update' || message.type === 'game_started') {\n                this.onGameUpdate(message.data);\n            }\n        };\n\n        this.ws.onclose = () => {\n            console.log('WebSocket connection closed');\n            // 可以在这里添加重连逻辑\n        };\n    }\n\n    completeTask(taskId: string) {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.send(JSON.stringify({\n                type: 'complete_task',\n                game_id: this.gameId,\n                task_id: taskId\n            }));\n        }\n    }\n\n    disconnect() {\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}