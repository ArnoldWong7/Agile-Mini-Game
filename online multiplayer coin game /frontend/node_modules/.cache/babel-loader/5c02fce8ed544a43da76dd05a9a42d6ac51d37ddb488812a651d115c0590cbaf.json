{"ast":null,"code":"import axios from 'axios';\nconst API_URL = 'http://172.20.10.4:8000';\nconst WS_URL = 'ws://172.20.10.4:8000';\n\n// 定义重试策略\nconst RETRY_DELAYS = [1000, 2000, 3000, 5000, 8000]; // 递增的重试延迟\n\nexport const gameService = {\n  createGame: async (playerCount, maxBatches, tasksPerBatch) => {\n    console.log('Creating game with params:', {\n      playerCount,\n      maxBatches,\n      tasksPerBatch\n    });\n    const response = await axios.post(`${API_URL}/games/create`, null, {\n      params: {\n        player_count: playerCount,\n        max_batches: maxBatches,\n        tasks_per_batch: tasksPerBatch\n      }\n    });\n    console.log('Game created:', response.data);\n    return response.data.game_id;\n  },\n  checkGameExists: async gameId => {\n    console.log('Checking if game exists:', gameId);\n    const response = await axios.get(`${API_URL}/games/${gameId}/exists`);\n    console.log('Game exists response:', response.data);\n    return response.data.exists;\n  },\n  joinGame: async (gameId, playerName) => {\n    console.log('Joining game:', {\n      gameId,\n      playerName\n    });\n    const response = await axios.post(`${API_URL}/games/${gameId}/join`, null, {\n      params: {\n        player_name: playerName\n      }\n    });\n    console.log('Join game response:', response.data);\n    return response.data.player_id;\n  },\n  startGame: async gameId => {\n    console.log('Starting game:', gameId);\n    await axios.post(`${API_URL}/games/${gameId}/start`);\n    console.log('Game started');\n  },\n  getGameState: async gameId => {\n    console.log('Getting game state:', gameId);\n    const response = await axios.get(`${API_URL}/games/${gameId}`);\n    console.log('Game state:', response.data);\n    return response.data;\n  }\n};\nexport class WebSocketService {\n  constructor(gameId, playerId, onGameUpdate) {\n    this.ws = null;\n    this.gameId = void 0;\n    this.playerId = void 0;\n    this.onGameUpdate = void 0;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.messageQueue = [];\n    this.isConnecting = false;\n    this.pingInterval = null;\n    this.lastPongTime = Date.now();\n    this.connectionTimeout = null;\n    this.CONNECTION_TIMEOUT = 5000;\n    // 5 seconds\n    // 修改错误回调的类型\n    this.onError = null;\n    this.onConnectionChange = null;\n    this.gameId = gameId;\n    this.playerId = playerId;\n    this.onGameUpdate = onGameUpdate;\n    console.log('WebSocket service initialized:', {\n      gameId,\n      playerId\n    });\n\n    // 添加页面卸载时的清理\n    window.addEventListener('beforeunload', () => {\n      this.cleanup();\n    });\n  }\n  async connect() {\n    if (this.isConnecting) {\n      console.log('Connection attempt already in progress');\n      return;\n    }\n    this.isConnecting = true;\n    console.log('Connecting WebSocket...');\n    try {\n      await this.establishConnection();\n    } catch (error) {\n      console.error('Error establishing connection:', error);\n      this.handleReconnect();\n      throw error;\n    } finally {\n      this.isConnecting = false;\n    }\n  }\n  async establishConnection() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(`${WS_URL}/ws/${this.playerId}`);\n\n        // 设置连接超时\n        this.connectionTimeout = setTimeout(() => {\n          var _this$ws;\n          if (((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) !== WebSocket.OPEN) {\n            console.error('Connection timeout');\n            this.cleanup();\n            reject(new Error('Connection timeout'));\n          }\n        }, this.CONNECTION_TIMEOUT);\n        this.ws.onopen = this.handleOpen.bind(this);\n        this.ws.onmessage = this.handleMessage.bind(this);\n        this.ws.onclose = this.handleClose.bind(this);\n        this.ws.onerror = error => {\n          this.handleError(error);\n          reject(error);\n        };\n\n        // 添加一次性的成功处理器\n        const successHandler = () => {\n          var _this$ws2;\n          if (this.connectionTimeout) {\n            clearTimeout(this.connectionTimeout);\n            this.connectionTimeout = null;\n          }\n          (_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.removeEventListener('open', successHandler);\n          resolve();\n        };\n        this.ws.addEventListener('open', successHandler);\n      } catch (error) {\n        console.error('Error creating WebSocket:', error);\n        reject(error);\n      }\n    });\n  }\n  handleMessage(event) {\n    var _this$onError;\n    try {\n      const message = JSON.parse(event.data);\n      console.log('WebSocket message received:', message);\n      switch (message.type) {\n        case 'game_update':\n        case 'game_started':\n          console.log('Updating game state:', message.data);\n          this.onGameUpdate(message.data);\n          break;\n        case 'pong':\n          this.lastPongTime = Date.now();\n          break;\n        case 'connection_status':\n          console.log('Connection status:', message.status);\n          if (message.status === 'connected') {\n            var _this$onConnectionCha;\n            (_this$onConnectionCha = this.onConnectionChange) === null || _this$onConnectionCha === void 0 ? void 0 : _this$onConnectionCha.call(this, true);\n            this.processMessageQueue();\n          }\n          break;\n        case 'error':\n          console.error('Server error:', message.message);\n          const serverError = new Error(message.message || 'Server error');\n          (_this$onError = this.onError) === null || _this$onError === void 0 ? void 0 : _this$onError.call(this, serverError);\n          break;\n        default:\n          console.log('Unknown message type:', message.type);\n      }\n    } catch (error) {\n      var _this$onError2;\n      console.error('Error processing message:', error);\n      const processError = error instanceof Error ? error : new Error('Failed to process WebSocket message');\n      (_this$onError2 = this.onError) === null || _this$onError2 === void 0 ? void 0 : _this$onError2.call(this, processError);\n    }\n  }\n  handleOpen() {\n    var _this$onConnectionCha2;\n    console.log('WebSocket connection opened');\n    this.reconnectAttempts = 0;\n    this.startPingInterval();\n    (_this$onConnectionCha2 = this.onConnectionChange) === null || _this$onConnectionCha2 === void 0 ? void 0 : _this$onConnectionCha2.call(this, true);\n    this.processMessageQueue();\n  }\n  handleClose(event) {\n    var _this$onConnectionCha3;\n    console.log('WebSocket connection closed:', event.code, event.reason);\n    this.cleanup();\n    (_this$onConnectionCha3 = this.onConnectionChange) === null || _this$onConnectionCha3 === void 0 ? void 0 : _this$onConnectionCha3.call(this, false);\n    this.handleReconnect();\n  }\n  handleError(error) {\n    var _this$onError3;\n    console.error('WebSocket error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'WebSocket connection error';\n    const formattedError = new Error(errorMessage);\n    (_this$onError3 = this.onError) === null || _this$onError3 === void 0 ? void 0 : _this$onError3.call(this, formattedError);\n    this.cleanup();\n  }\n  startPingInterval() {\n    this.pingInterval = setInterval(() => {\n      var _this$ws3;\n      if (((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN) {\n        try {\n          this.ws.send(JSON.stringify({\n            type: 'ping'\n          }));\n\n          // 检查是否超时\n          const now = Date.now();\n          if (now - this.lastPongTime > 10000) {\n            // 10秒超时\n            console.error('WebSocket connection timeout');\n            this.cleanup();\n            this.connect().catch(error => {\n              var _this$onError4;\n              console.error('Reconnection failed:', error);\n              (_this$onError4 = this.onError) === null || _this$onError4 === void 0 ? void 0 : _this$onError4.call(this, error instanceof Error ? error : new Error('Reconnection failed'));\n            });\n          }\n        } catch (error) {\n          var _this$onError5;\n          console.error('Error sending ping:', error);\n          (_this$onError5 = this.onError) === null || _this$onError5 === void 0 ? void 0 : _this$onError5.call(this, error instanceof Error ? error : new Error('Error sending ping'));\n        }\n      }\n    }, 5000); // 每5秒发送一次ping\n  }\n  cleanup() {\n    if (this.connectionTimeout) {\n      clearTimeout(this.connectionTimeout);\n      this.connectionTimeout = null;\n    }\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n    if (this.ws) {\n      try {\n        this.ws.close();\n      } catch (error) {\n        console.error('Error closing WebSocket:', error);\n      }\n      this.ws = null;\n    }\n  }\n  async handleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      const delay = RETRY_DELAYS[this.reconnectAttempts] || RETRY_DELAYS[RETRY_DELAYS.length - 1];\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      try {\n        await this.connect();\n      } catch (error) {\n        var _this$onError6;\n        console.error('Reconnection attempt failed:', error);\n        (_this$onError6 = this.onError) === null || _this$onError6 === void 0 ? void 0 : _this$onError6.call(this, error instanceof Error ? error : new Error('Reconnection attempt failed'));\n      }\n    } else {\n      var _this$onError7;\n      console.error('Max reconnection attempts reached');\n      (_this$onError7 = this.onError) === null || _this$onError7 === void 0 ? void 0 : _this$onError7.call(this, new Error('Max reconnection attempts reached'));\n    }\n  }\n  queueMessage(message) {\n    this.messageQueue.push(message);\n    console.log('Message queued:', message);\n    this.processMessageQueue();\n  }\n  async processMessageQueue() {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.log('WebSocket not ready, skipping message queue processing');\n      return;\n    }\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue[0];\n      try {\n        await this.sendMessage(message);\n        this.messageQueue.shift(); // 移除已发送的消息\n      } catch (error) {\n        console.error('Error sending queued message:', error);\n        message.attempts++;\n        if (message.attempts >= message.maxAttempts) {\n          var _this$onError8;\n          console.error('Max attempts reached for message:', message);\n          this.messageQueue.shift(); // 移除失败的消息\n          (_this$onError8 = this.onError) === null || _this$onError8 === void 0 ? void 0 : _this$onError8.call(this, new Error(`Failed to send message after ${message.maxAttempts} attempts`));\n        }\n        break; // 停止处理队列\n      }\n    }\n  }\n  async sendMessage(message) {\n    return new Promise((resolve, reject) => {\n      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n        reject(new Error('WebSocket not connected'));\n        return;\n      }\n      try {\n        this.ws.send(JSON.stringify(message.data));\n        resolve();\n      } catch (error) {\n        reject(error instanceof Error ? error : new Error('Failed to send message'));\n      }\n    });\n  }\n  completeTask(taskId) {\n    const message = {\n      type: 'complete_task',\n      game_id: this.gameId,\n      task_id: taskId\n    };\n    this.queueMessage({\n      type: 'complete_task',\n      data: message,\n      attempts: 0,\n      maxAttempts: 3\n    });\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.log('WebSocket not connected, attempting to reconnect');\n      this.connect();\n    }\n  }\n  disconnect() {\n    var _this$onConnectionCha4;\n    console.log('Disconnecting WebSocket');\n    this.cleanup();\n    (_this$onConnectionCha4 = this.onConnectionChange) === null || _this$onConnectionCha4 === void 0 ? void 0 : _this$onConnectionCha4.call(this, false);\n  }\n}","map":{"version":3,"names":["axios","API_URL","WS_URL","RETRY_DELAYS","gameService","createGame","playerCount","maxBatches","tasksPerBatch","console","log","response","post","params","player_count","max_batches","tasks_per_batch","data","game_id","checkGameExists","gameId","get","exists","joinGame","playerName","player_name","player_id","startGame","getGameState","WebSocketService","constructor","playerId","onGameUpdate","ws","reconnectAttempts","maxReconnectAttempts","messageQueue","isConnecting","pingInterval","lastPongTime","Date","now","connectionTimeout","CONNECTION_TIMEOUT","onError","onConnectionChange","window","addEventListener","cleanup","connect","establishConnection","error","handleReconnect","Promise","resolve","reject","WebSocket","setTimeout","_this$ws","readyState","OPEN","Error","onopen","handleOpen","bind","onmessage","handleMessage","onclose","handleClose","onerror","handleError","successHandler","_this$ws2","clearTimeout","removeEventListener","event","_this$onError","message","JSON","parse","type","status","_this$onConnectionCha","call","processMessageQueue","serverError","_this$onError2","processError","_this$onConnectionCha2","startPingInterval","_this$onConnectionCha3","code","reason","_this$onError3","errorMessage","formattedError","setInterval","_this$ws3","send","stringify","catch","_this$onError4","_this$onError5","clearInterval","close","delay","length","_this$onError6","_this$onError7","queueMessage","push","sendMessage","shift","attempts","maxAttempts","_this$onError8","completeTask","taskId","task_id","disconnect","_this$onConnectionCha4"],"sources":["/Users/huanghao/Desktop/online multiplayer coin game/frontend/src/services/gameService.ts"],"sourcesContent":["import axios from 'axios';\nimport { Game, WebSocketMessage } from '../types';\n\nconst API_URL = 'http://172.20.10.4:8000';\nconst WS_URL = 'ws://172.20.10.4:8000';\n\n// 定义重试策略\nconst RETRY_DELAYS = [1000, 2000, 3000, 5000, 8000]; // 递增的重试延迟\n\ninterface QueuedMessage {\n    type: string;\n    data: any;\n    attempts: number;\n    maxAttempts: number;\n}\n\nexport const gameService = {\n    createGame: async (playerCount: number, maxBatches: number, tasksPerBatch: number): Promise<string> => {\n        console.log('Creating game with params:', { playerCount, maxBatches, tasksPerBatch });\n        const response = await axios.post(`${API_URL}/games/create`, null, {\n            params: { player_count: playerCount, max_batches: maxBatches, tasks_per_batch: tasksPerBatch }\n        });\n        console.log('Game created:', response.data);\n        return response.data.game_id;\n    },\n\n    checkGameExists: async (gameId: string): Promise<boolean> => {\n        console.log('Checking if game exists:', gameId);\n        const response = await axios.get(`${API_URL}/games/${gameId}/exists`);\n        console.log('Game exists response:', response.data);\n        return response.data.exists;\n    },\n\n    joinGame: async (gameId: string, playerName: string): Promise<string> => {\n        console.log('Joining game:', { gameId, playerName });\n        const response = await axios.post(`${API_URL}/games/${gameId}/join`, null, {\n            params: { player_name: playerName }\n        });\n        console.log('Join game response:', response.data);\n        return response.data.player_id;\n    },\n\n    startGame: async (gameId: string): Promise<void> => {\n        console.log('Starting game:', gameId);\n        await axios.post(`${API_URL}/games/${gameId}/start`);\n        console.log('Game started');\n    },\n\n    getGameState: async (gameId: string): Promise<Game> => {\n        console.log('Getting game state:', gameId);\n        const response = await axios.get(`${API_URL}/games/${gameId}`);\n        console.log('Game state:', response.data);\n        return response.data;\n    }\n};\n\nexport class WebSocketService {\n    private ws: WebSocket | null = null;\n    private gameId: string;\n    private playerId: string;\n    private onGameUpdate: (game: Game) => void;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = 5;\n    private messageQueue: QueuedMessage[] = [];\n    private isConnecting: boolean = false;\n    private pingInterval: NodeJS.Timeout | null = null;\n    private lastPongTime: number = Date.now();\n    private connectionTimeout: NodeJS.Timeout | null = null;\n    private readonly CONNECTION_TIMEOUT = 5000; // 5 seconds\n    \n    // 修改错误回调的类型\n    public onError: ((error: Error | Event) => void) | null = null;\n    public onConnectionChange: ((connected: boolean) => void) | null = null;\n\n    constructor(gameId: string, playerId: string, onGameUpdate: (game: Game) => void) {\n        this.gameId = gameId;\n        this.playerId = playerId;\n        this.onGameUpdate = onGameUpdate;\n        console.log('WebSocket service initialized:', { gameId, playerId });\n        \n        // 添加页面卸载时的清理\n        window.addEventListener('beforeunload', () => {\n            this.cleanup();\n        });\n    }\n\n    async connect(): Promise<void> {\n        if (this.isConnecting) {\n            console.log('Connection attempt already in progress');\n            return;\n        }\n\n        this.isConnecting = true;\n        console.log('Connecting WebSocket...');\n\n        try {\n            await this.establishConnection();\n        } catch (error) {\n            console.error('Error establishing connection:', error);\n            this.handleReconnect();\n            throw error;\n        } finally {\n            this.isConnecting = false;\n        }\n    }\n\n    private async establishConnection(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            try {\n                this.ws = new WebSocket(`${WS_URL}/ws/${this.playerId}`);\n                \n                // 设置连接超时\n                this.connectionTimeout = setTimeout(() => {\n                    if (this.ws?.readyState !== WebSocket.OPEN) {\n                        console.error('Connection timeout');\n                        this.cleanup();\n                        reject(new Error('Connection timeout'));\n                    }\n                }, this.CONNECTION_TIMEOUT);\n\n                this.ws.onopen = this.handleOpen.bind(this);\n                this.ws.onmessage = this.handleMessage.bind(this);\n                this.ws.onclose = this.handleClose.bind(this);\n                this.ws.onerror = (error: Event) => {\n                    this.handleError(error);\n                    reject(error);\n                };\n\n                // 添加一次性的成功处理器\n                const successHandler = () => {\n                    if (this.connectionTimeout) {\n                        clearTimeout(this.connectionTimeout);\n                        this.connectionTimeout = null;\n                    }\n                    this.ws?.removeEventListener('open', successHandler);\n                    resolve();\n                };\n                this.ws.addEventListener('open', successHandler);\n\n            } catch (error) {\n                console.error('Error creating WebSocket:', error);\n                reject(error);\n            }\n        });\n    }\n\n    private handleMessage(event: MessageEvent) {\n        try {\n            const message = JSON.parse(event.data);\n            console.log('WebSocket message received:', message);\n            \n            switch (message.type) {\n                case 'game_update':\n                case 'game_started':\n                    console.log('Updating game state:', message.data);\n                    this.onGameUpdate(message.data);\n                    break;\n                case 'pong':\n                    this.lastPongTime = Date.now();\n                    break;\n                case 'connection_status':\n                    console.log('Connection status:', message.status);\n                    if (message.status === 'connected') {\n                        this.onConnectionChange?.(true);\n                        this.processMessageQueue();\n                    }\n                    break;\n                case 'error':\n                    console.error('Server error:', message.message);\n                    const serverError = new Error(message.message || 'Server error');\n                    this.onError?.(serverError);\n                    break;\n                default:\n                    console.log('Unknown message type:', message.type);\n            }\n        } catch (error) {\n            console.error('Error processing message:', error);\n            const processError = error instanceof Error ? error : new Error('Failed to process WebSocket message');\n            this.onError?.(processError);\n        }\n    }\n\n    private handleOpen() {\n        console.log('WebSocket connection opened');\n        this.reconnectAttempts = 0;\n        this.startPingInterval();\n        this.onConnectionChange?.(true);\n        this.processMessageQueue();\n    }\n\n    private handleClose(event: CloseEvent) {\n        console.log('WebSocket connection closed:', event.code, event.reason);\n        this.cleanup();\n        this.onConnectionChange?.(false);\n        this.handleReconnect();\n    }\n\n    private handleError(error: Event) {\n        console.error('WebSocket error:', error);\n        const errorMessage = error instanceof Error ? error.message : 'WebSocket connection error';\n        const formattedError = new Error(errorMessage);\n        this.onError?.(formattedError);\n        this.cleanup();\n    }\n\n    private startPingInterval() {\n        this.pingInterval = setInterval(() => {\n            if (this.ws?.readyState === WebSocket.OPEN) {\n                try {\n                    this.ws.send(JSON.stringify({ type: 'ping' }));\n                    \n                    // 检查是否超时\n                    const now = Date.now();\n                    if (now - this.lastPongTime > 10000) { // 10秒超时\n                        console.error('WebSocket connection timeout');\n                        this.cleanup();\n                        this.connect().catch(error => {\n                            console.error('Reconnection failed:', error);\n                            this.onError?.(error instanceof Error ? error : new Error('Reconnection failed'));\n                        });\n                    }\n                } catch (error) {\n                    console.error('Error sending ping:', error);\n                    this.onError?.(error instanceof Error ? error : new Error('Error sending ping'));\n                }\n            }\n        }, 5000); // 每5秒发送一次ping\n    }\n\n    private cleanup() {\n        if (this.connectionTimeout) {\n            clearTimeout(this.connectionTimeout);\n            this.connectionTimeout = null;\n        }\n\n        if (this.pingInterval) {\n            clearInterval(this.pingInterval);\n            this.pingInterval = null;\n        }\n        \n        if (this.ws) {\n            try {\n                this.ws.close();\n            } catch (error) {\n                console.error('Error closing WebSocket:', error);\n            }\n            this.ws = null;\n        }\n    }\n\n    private async handleReconnect() {\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\n            const delay = RETRY_DELAYS[this.reconnectAttempts] || RETRY_DELAYS[RETRY_DELAYS.length - 1];\n            this.reconnectAttempts++;\n            console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts}) in ${delay}ms...`);\n            \n            await new Promise(resolve => setTimeout(resolve, delay));\n            \n            try {\n                await this.connect();\n            } catch (error) {\n                console.error('Reconnection attempt failed:', error);\n                this.onError?.(error instanceof Error ? error : new Error('Reconnection attempt failed'));\n            }\n        } else {\n            console.error('Max reconnection attempts reached');\n            this.onError?.(new Error('Max reconnection attempts reached'));\n        }\n    }\n\n    private queueMessage(message: QueuedMessage) {\n        this.messageQueue.push(message);\n        console.log('Message queued:', message);\n        this.processMessageQueue();\n    }\n\n    private async processMessageQueue() {\n        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n            console.log('WebSocket not ready, skipping message queue processing');\n            return;\n        }\n\n        while (this.messageQueue.length > 0) {\n            const message = this.messageQueue[0];\n            \n            try {\n                await this.sendMessage(message);\n                this.messageQueue.shift(); // 移除已发送的消息\n            } catch (error) {\n                console.error('Error sending queued message:', error);\n                message.attempts++;\n                \n                if (message.attempts >= message.maxAttempts) {\n                    console.error('Max attempts reached for message:', message);\n                    this.messageQueue.shift(); // 移除失败的消息\n                    this.onError?.(new Error(`Failed to send message after ${message.maxAttempts} attempts`));\n                }\n                \n                break; // 停止处理队列\n            }\n        }\n    }\n\n    private async sendMessage(message: QueuedMessage): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n                reject(new Error('WebSocket not connected'));\n                return;\n            }\n\n            try {\n                this.ws.send(JSON.stringify(message.data));\n                resolve();\n            } catch (error) {\n                reject(error instanceof Error ? error : new Error('Failed to send message'));\n            }\n        });\n    }\n\n    completeTask(taskId: string) {\n        const message = {\n            type: 'complete_task',\n            game_id: this.gameId,\n            task_id: taskId\n        };\n\n        this.queueMessage({\n            type: 'complete_task',\n            data: message,\n            attempts: 0,\n            maxAttempts: 3\n        });\n\n        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n            console.log('WebSocket not connected, attempting to reconnect');\n            this.connect();\n        }\n    }\n\n    disconnect() {\n        console.log('Disconnecting WebSocket');\n        this.cleanup();\n        this.onConnectionChange?.(false);\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}